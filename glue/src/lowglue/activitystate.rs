use std::any::Any;
use std::sync::atomic::{AtomicPtr, AtomicIsize, AtomicBool, Ordering};
use std::sync::{Mutex, Arc, Condvar, LockResult, MutexGuard};
use std::mem::transmute;
use std::time::Duration;

use super::InputEvent;
use super::InputQueue;
//use super::NativeActivity;
use super::NativeWindow;
use super::Looper;
use super::Rect;
use super::Configuration;
use super::StaticTypeUnixPipe;
use libc;
use ffi;

// The glue code activity state structure.
pub struct ActivityState {
    pub userdata:          Mutex<Box<Any + Send>>,
    // Virtual callbacks. Generated by lib.
    pub onappcmd:          AtomicPtr<()>,
    pub oninputevent:      AtomicPtr<()>,
    // Direct callbacks. Can override lib.
    pub oninputqueuedestroyed:      AtomicPtr<()>,
    pub oninputqueuecreated:        AtomicPtr<()>,
    pub onnativewindowdestroyed:    AtomicPtr<()>,
    pub onnativewindowcreated:      AtomicPtr<()>,
    pub onwindowfocuschanged:       AtomicPtr<()>,
    pub onlowmemory:                AtomicPtr<()>,
    pub onconfigurationchanged:     AtomicPtr<()>,
    pub onstop:                     AtomicPtr<()>,
    pub onpause:                    AtomicPtr<()>,
    pub onsaveinstancestate:        AtomicPtr<()>,
    pub onresume:                   AtomicPtr<()>,
    pub onstart:                    AtomicPtr<()>,
    pub ondestroy:                  AtomicPtr<()>,
    //
    pub activity:          *mut ffi::ANativeActivity,
    pub config:            MutexWait<Option<Configuration>>,
    pub savedstate:        MutexWait<Option<Vec<u8>>>,
    pub looper:            MutexWait<Option<Looper>>,
    pub inputqueue:        MutexWait<Option<InputQueue>>,
    pub window:            MutexWait<Option<NativeWindow>>,
    pub contentrect:       MutexWait<Option<Rect>>,
    pub activitystate:     MutexWait<isize>,
    pub destroyrequested:  AtomicBool,
    pub running:           AtomicBool,
    pub statesaved:        MutexWait<bool>,
    pub destroyed:         MutexWait<bool>,
    pub redrawneeded:      AtomicBool,
    /// To maintain behavior of original C code. This is used to send
    /// commands back to the looper thread. To make use of the looper
    /// we have to use a Unix pipe, which has a file descriptor.
    pub cmdpipe:           StaticTypeUnixPipe<i8>,
    pub pendinginputqueue: MutexWait<Option<(bool, InputQueue)>>,
    pub pendingwindow:     MutexWait<Option<(bool, NativeWindow)>>,
    /// The callback structures.
    pub cmdpollsource:     AndroidPollSource,
    pub inputpollsource:   AndroidPollSource,
}

/// This is mostly just useful for debugging. To help us know when
/// the entire structure is dropped from memory.
impl Drop for ActivityState {
    fn drop(&mut self) {
        println!("<ActivityState> Dropped (Memory Free)");
    }
}

/// This just pairs up the `Mutex` and `Condvar`. This
/// make it more ergonomic to use them together, and it
/// helps ensure that the same mutex is used with the same
/// condition variable.
///
/// _At the moment the Rust standard library's Condvar has
/// a restriction that it is dynamically bound to the first
/// used mutex. This means we need a conditional variable per
/// mutex._
pub struct MutexWait<T> {
    pub mutex:      Mutex<T>,
    pub cond:       Condvar,
    pub dbgname:    &'static str,
}

impl<T: Send> MutexWait<T> {
    pub fn new(t: T, dbgname: &'static str) -> MutexWait<T> {
        MutexWait {
            mutex:      Mutex::new(t),
            cond:       Condvar::new(),
            dbgname:    dbgname,
        }
    }
    pub fn lock(&self) -> LockResult<MutexGuard<T>> {
        self.mutex.lock()
    }
    pub fn wait<'a>(&self, guard: MutexGuard<'a, T>) -> LockResult<MutexGuard<'a, T>> {
        self.cond.wait(guard)
    }
    pub fn wait_timeout<'a>(&self, guard: MutexGuard<'a, T>, ms: u32) -> LockResult<(MutexGuard<'a, T>, bool)> {
        self.cond.wait_timeout_ms(guard, ms)
    }
    pub fn notify_all(&self) {
        self.cond.notify_all();
    }
}

pub struct AndroidPollSource {
    pub id:         AtomicIsize,
    pub process:    AtomicPtr<()>,
}

impl AndroidPollSource {
    pub fn setprocess(&self, f: fn(Arc<ActivityState>)) {
        unsafe { self.process.store(transmute(f), Ordering::Relaxed); }
    }

    pub fn callprocess(&self, astate: Arc<ActivityState>) -> bool {
        unsafe {
            let ptr = self.process.load(Ordering::Relaxed);
            if ptr.is_null() {
                return false;
            }
            let f: fn(Arc<ActivityState>) = transmute(ptr);
            f(astate);
            true
        }
    }
}

unsafe impl Send for ActivityState { }
unsafe impl Sync for ActivityState { }

impl ActivityState {
    pub fn callonappcmd(&self, activity: Arc<ActivityState>, cmd: libc::int32_t) {
        unsafe { 
            let ptr = self.onappcmd.load(Ordering::Relaxed);
            if ptr.is_null() {
                return;
            }
            let f: fn(Arc<ActivityState>, libc::int32_t) = transmute(ptr);
            f(activity, cmd)
        }
    }
    pub fn calloninputevent(&self, activity: Arc<ActivityState>, event: InputEvent) -> libc::int32_t {
        unsafe {
            let ptr = self.oninputevent.load(Ordering::Relaxed);
            if ptr.is_null() {
                return 0;
            }
            let f: fn(Arc<ActivityState>, InputEvent) -> libc::int32_t = transmute(ptr);
            f(activity, event)
        }
    }
    pub fn setondestroy(&self, cb: fn(&Arc<ActivityState>) -> isize) {
        unsafe { self.ondestroy.store(transmute(cb), Ordering::Relaxed); }
    }
    pub fn callondestroy(&self, activity: &Arc<ActivityState>) -> isize {
        unsafe {
            let p = self.ondestroy.load(Ordering::Relaxed);
            if p.is_null() {
                return 0;
            }
            let f: fn(&Arc<ActivityState>) -> isize =
                transmute(p);
            f(activity)
        }
    }
    pub fn setonstart(&self, cb: fn(&Arc<ActivityState>)) {
        unsafe { self.onstart.store(transmute(cb), Ordering::Relaxed); }
    }
    pub fn callonstart(&self, activity: &Arc<ActivityState>) -> isize {
        unsafe {
            let p = self.onstart.load(Ordering::Relaxed);
            if p.is_null() {
                return 0;
            }
            let f: fn(&Arc<ActivityState>) -> isize =
                transmute(p);
            f(activity)
        }
    }
    pub fn setonresume(&self, cb: fn(&Arc<ActivityState>)) {
        unsafe { self.onresume.store(transmute(cb), Ordering::Relaxed); }
    }
    pub fn callonresume(&self, activity: &Arc<ActivityState>) -> isize {
        unsafe {
            let p = self.onresume.load(Ordering::Relaxed);
            if p.is_null() {
                return 0;
            }
            let f: fn(&Arc<ActivityState>) -> isize = transmute(p);
            f(activity)
        }
    }
    pub fn setonsaveinstancestate(&self, cb: fn(&Arc<ActivityState>) -> (isize, Option<Vec<u8>>)) {
        unsafe { self.onsaveinstancestate.store(transmute(cb), Ordering::Relaxed); }
    }
    pub fn callonsaveinstancestate(&self, activity: &Arc<ActivityState>) -> (isize, Option<Vec<u8>>) {
        unsafe {
            let p = self.onsaveinstancestate.load(Ordering::Relaxed);
            if p.is_null() {
                return (0, Option::None);
            }
            let f: fn(&Arc<ActivityState>) -> (isize, Option<Vec<u8>>) = transmute(p);
            f(activity)
        }
    }
    pub fn setonpause(&self, cb: fn(&Arc<ActivityState>)) {
        unsafe { self.onpause.store(transmute(cb), Ordering::Relaxed); }
    }
    pub fn callonpause(&self, activity: &Arc<ActivityState>) -> isize {
        unsafe {
            let p = self.onpause.load(Ordering::Relaxed);
            if p.is_null() {
                return 0;
            }
            let f: fn(&Arc<ActivityState>) -> isize = transmute(p);
            f(activity)
        }
    }    
    pub fn setonstop(&self, cb: fn(&Arc<ActivityState>) -> isize) {
        unsafe { self.onstop.store(transmute(cb), Ordering::Relaxed); }
    }
    pub fn callonstop(&self, activity: &Arc<ActivityState>) -> isize {
        unsafe {
            let p = self.onstop.load(Ordering::Relaxed);
            if p.is_null() {
                return 0;
            }
            let f: fn(&Arc<ActivityState>) -> isize = transmute(p);
            f(activity)
        }
    }
    pub fn setonconfigurationchanged(&self, cb: fn(&Arc<ActivityState>) -> isize) {
        unsafe { self.onconfigurationchanged.store(transmute(cb), Ordering::Relaxed); }
    }
    pub fn callonconfigurationchanged(&self, activity: &Arc<ActivityState>) -> isize {
        unsafe {
            let p = self.onconfigurationchanged.load(Ordering::Relaxed);
            if p.is_null() {
                return 0;
            }
            let f: fn(&Arc<ActivityState>) -> isize = transmute(p);
            f(activity)
        }
    }
    pub fn setonlowmemory(&self, cb: fn(&Arc<ActivityState>) -> isize) {
        unsafe { self.onlowmemory.store(transmute(cb), Ordering::Relaxed); }
    }
    pub fn callonlowmemory(&self, activity: &Arc<ActivityState>) -> isize {
        unsafe {
            let p = self.onlowmemory.load(Ordering::Relaxed);
            if p.is_null() {
                return 0;
            }
            let f: fn(&Arc<ActivityState>) -> isize = transmute(p);
            f(activity)
        }
    }
    pub fn setonwindowfocuschanged(&self, cb: fn(&Arc<ActivityState>, libc::c_int)) {
        unsafe { self.onwindowfocuschanged.store(transmute(cb), Ordering::Relaxed); }
    }
    pub fn callonwindowfocuschanged(&self, activity: &Arc<ActivityState>, unk: libc::c_int) -> isize {
        unsafe {
            let p = self.onwindowfocuschanged.load(Ordering::Relaxed);
            if p.is_null() {
                return 0;
            }
            let f: fn(&Arc<ActivityState>, libc::c_int) -> isize = transmute(p);
            f(activity, unk)
        }
    }
    pub fn setonnativewindowcreated(&self, cb: fn(&Arc<ActivityState>, &NativeWindow)) {
        unsafe { self.onnativewindowcreated.store(transmute(cb), Ordering::Relaxed); }
    }
    pub fn callonnativewindowcreated(&self, activity: &Arc<ActivityState>, win: &NativeWindow) -> isize {
        unsafe {
            let p = self.onnativewindowcreated.load(Ordering::Relaxed);
            if p.is_null() {
                return 0;
            }
            let f: fn(&Arc<ActivityState>, &NativeWindow) -> isize = transmute(p);
            f(activity, win)
        }
    }
    pub fn setonnativewindowdestroyed(&self, cb: fn(&Arc<ActivityState>, &NativeWindow)) {
        unsafe { self.onnativewindowdestroyed.store(transmute(cb), Ordering::Relaxed); }
    }
    pub fn callonnativewindowdestroyed(&self, activity: &Arc<ActivityState>, win: &NativeWindow) -> isize {
        unsafe {
            let p = self.onnativewindowdestroyed.load(Ordering::Relaxed);
            if p.is_null() {
                return 0;
            }
            let f: fn(&Arc<ActivityState>, &NativeWindow) -> isize = transmute(p);
            f(activity, win)
        }
    }
    pub fn setoninputqueuedestroyed(&self, cb: fn(&Arc<ActivityState>, &InputQueue)) {
        unsafe { self.oninputqueuedestroyed.store(transmute(cb), Ordering::Relaxed); }
    }
    pub fn calloninputqueuedestroyed(&self, activity: &Arc<ActivityState>, queue: &InputQueue) -> isize {
        unsafe {
            let p = self.onpause.load(Ordering::Relaxed);
            if p.is_null() {
                return 0;
            }
            let f: fn(&Arc<ActivityState>, &InputQueue) -> isize = transmute(p);
            f(activity, queue)
        }
    }
    pub fn setoninputqueuecreated(&self, cb: fn(&Arc<ActivityState>, &InputQueue) -> isize) {
        unsafe { self.oninputqueuecreated.store(transmute(cb), Ordering::Relaxed); }
    } 
    pub fn calloninputqueuecreated(&self, activity: &Arc<ActivityState>, queue: &InputQueue) -> isize {
        unsafe {
            let p = self.onpause.load(Ordering::Relaxed);
            if p.is_null() {
                return 0;
            }
            let f: fn(&Arc<ActivityState>, &InputQueue) -> isize = transmute(p);
            f(activity, queue)
        }
    }    
    pub fn setonappcmd(&self, cb: fn(Arc<ActivityState>, libc::int32_t)) { 
        unsafe { self.onappcmd.store(transmute(cb), Ordering::Relaxed); }
    }
    pub fn setoninputevent(&self, cb: fn(Arc<ActivityState>, InputEvent) -> libc::int32_t) {
        unsafe { self.oninputevent.store(transmute(cb), Ordering::Relaxed); }
    }
}